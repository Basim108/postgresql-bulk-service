using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using JetBrains.Annotations;
using Microsoft.Extensions.Logging;
using Npgsql;

namespace Hrimsoft.SqlBulk.PostgreSql
{
    /// <summary>
    /// Sql bulk upset command generator 
    /// </summary>
    public class UpsertSqlCommandBuilder : IUpsertSqlCommandBuilder
    {
        private readonly ILogger<UpsertSqlCommandBuilder> _logger;

        /// <inheritdoc />
        public UpsertSqlCommandBuilder(ILoggerFactory loggerFactory)
        {
            _logger = loggerFactory.CreateLogger<UpsertSqlCommandBuilder>();
        }

        /// <summary>
        /// Generates sql upset command for bunch of elements
        /// </summary>
        /// <param name="elements">elements that have to be upserted</param>
        /// <param name="entityProfile">elements type profile (contains mapping and other options)</param>
        /// <param name="cancellationToken"></param>
        /// <returns>Returns a text of an sql upset command and collection of database parameters</returns>
        public SqlCommandBuilderResult Generate<TEntity>([NotNull] ICollection<TEntity> elements, [NotNull] EntityProfile entityProfile, CancellationToken cancellationToken)
            where TEntity : class
        {
            if (elements.Count == 0)
                throw new ArgumentException("There is no elements in the collection. At least one element must be.", nameof(elements));

            if(entityProfile.UniqueConstraint == null)
                throw new ArgumentException($"There is no unique constraint defined in the {entityProfile.GetType().FullName}", nameof(entityProfile));
            if(entityProfile.UniqueConstraint.UniqueProperties.All(p => p == null))
                throw new ArgumentException($"There is no unique properties defined in the {entityProfile.GetType().FullName}", nameof(entityProfile));
            
            if (_logger.IsEnabled(LogLevel.Debug))
            {
                _logger.LogDebug($"{nameof(TEntity)}: {typeof(TEntity).FullName}");
                _logger.LogDebug($"{nameof(elements)}.Count: {elements.Count}");
            }

            var (columns, returningClause, upsertClause) = this.GenerateClauses(entityProfile);

            cancellationToken.ThrowIfCancellationRequested();

            var command = $"insert into {entityProfile.TableName} ({columns}) values ";
            var approximateEntireCommandLength = command.Length + returningClause.Length + columns.Length * elements.Count;

            if (_logger.IsEnabled(LogLevel.Debug))
                _logger.LogDebug($"approximateEntireCommandLength: {approximateEntireCommandLength}");

            var commandParameters = new List<NpgsqlParameter>();
            var resultBuilder = new StringBuilder(approximateEntireCommandLength);
            resultBuilder.Append(command);
            var elementIndex = -1;
            using (var elementsEnumerator = elements.GetEnumerator())
            {
                while (elementsEnumerator.MoveNext())
                {
                    var item = elementsEnumerator.Current;
                    if (item == null)
                        continue;

                    elementIndex++;
                    cancellationToken.ThrowIfCancellationRequested();
                    
                    resultBuilder.Append('(');
                    var firstPropertyValue = true;
                    foreach (var propInfo in entityProfile.Properties.Values)
                    {
                        if (propInfo.IsAutoGenerated)
                            continue;
                        var delimiter = firstPropertyValue
                            ? ""
                            : ", ";

                        var paramName = $"@param{commandParameters.Count}";
                        commandParameters.Add(new NpgsqlParameter(paramName, propInfo.DbColumnType)
                        {
                            Value = propInfo.GetPropertyValue(item)
                        });

                        resultBuilder.Append(delimiter);
                        resultBuilder.Append(paramName);

                        firstPropertyValue = false;
                    }

                    resultBuilder.Append(')');
                    //  Finished with properties 
                    if (elements.Count > 1 && elementIndex < elements.Count - 1)
                        resultBuilder.Append(", ");
                }
            }

            if (elementIndex == -1)
                throw new ArgumentException("There is no elements in the collection. At least one element must be.", nameof(elements));

            var hasReturningClause = !string.IsNullOrWhiteSpace(returningClause);
            if (hasReturningClause)
            {
                resultBuilder.AppendLine(upsertClause);
                resultBuilder.Append(" returning ");
                resultBuilder.Append(returningClause);
            }
            else
                resultBuilder.Append(upsertClause);

            resultBuilder.Append(";");

            var result = resultBuilder.ToString();
            if (_logger.IsEnabled(LogLevel.Debug))
                _logger.LogDebug($"result command: {result}");

            return new SqlCommandBuilderResult
            {
                Command = result,
                Parameters = commandParameters,
                IsThereReturningClause = hasReturningClause
            };
        }

        /// <summary>
        /// In one pass generates both columns and returning clauses 
        /// </summary>
        /// <param name="entityProfile">elements type profile (contains mapping and other options)</param>
        /// <returns>
        /// Returns named tuple with generated columns, returning and upsert clauses.
        /// If there is no properties that has to be included into returning clause then ReturningClause item in the result tuple will be an empty string.
        /// </returns>
        // ReSharper disable once MemberCanBePrivate.Global  Needed to be public for unit testing purpose
        public (string Columns, string ReturningClause, string UpsertClause) GenerateClauses([NotNull] EntityProfile entityProfile)
        {
            var properties = entityProfile.Properties.Values;
            var upsertClause = GenerateOnConflictClause(entityProfile.UniqueConstraint);
            var firstUpdateSetColumn = true;

            var returningClause = "";
            var firstReturningColumn = true;

            var columns = "";
            var firstColumn = true;
            foreach (var propInfo in properties)
            {
                if (propInfo.IsUpdatedAfterInsert || propInfo.IsUpdatedAfterUpdate)
                {
                    var returningDelimiter = firstReturningColumn
                        ? ""
                        : ", ";

                    returningClause += $"{returningDelimiter}\"{propInfo.DbColumnName}\"";
                    firstReturningColumn = false;
                }

                if (propInfo.IsAutoGenerated)
                    continue;

                if (!propInfo.IsPartOfUniqueConstraint)
                {
                    var upsertSetDelimiter = firstUpdateSetColumn
                        ? " do update set "
                        : ", ";

                    upsertClause += $"{upsertSetDelimiter}\"{propInfo.DbColumnName}\" = {entityProfile.TableName}.\"{propInfo.DbColumnName}\"";
                    firstUpdateSetColumn = false;
                }
                
                var delimiter = firstColumn
                    ? ""
                    : ", ";
                columns += $"{delimiter}\"{propInfo.DbColumnName}\"";

                firstColumn = false;
            }

            if (_logger.IsEnabled(LogLevel.Debug))
            {
                _logger.LogDebug($"columns: {columns}");
                _logger.LogDebug($"upsertClause: {upsertClause}");
                _logger.LogDebug($"returningClause: {returningClause}");
            }

            return (columns, returningClause, upsertClause);
        }

        /// <summary>
        /// Generate on conflict clause
        /// </summary>
        /// <param name="uniqueConstraintInfo"></param>
        /// <returns></returns>
        public string GenerateOnConflictClause([NotNull] EntityUniqueConstraint uniqueConstraintInfo)
        {
            var result = " on conflict ";
            if (string.IsNullOrWhiteSpace(uniqueConstraintInfo.Name))
            {
                var firstProperty = uniqueConstraintInfo.UniqueProperties.FirstOrDefault(p => p != null);
                if (firstProperty == null)
                    throw new SqlBulkServiceException(
                        "It is impossible to generate a constraint name as neither it as set in constructor nor properties have been set as a part of unique constraint.");
                result += $"(\"{firstProperty.DbColumnName}\")";
            }
            else
            {
                result += $"on constraint \"{uniqueConstraintInfo.Name}\"";
            }

            return result;
        }
        
    }
}