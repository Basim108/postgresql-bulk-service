using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading;
using JetBrains.Annotations;
using Microsoft.Extensions.Logging;

namespace Hrimsoft.PostgresSqlBulkService
{
    public class InsertSqlCommandBuilder
    {
        private readonly ILogger<InsertSqlCommandBuilder> _logger;
        
        public InsertSqlCommandBuilder(ILoggerFactory loggerFactory)
        {
            _logger = loggerFactory.CreateLogger<InsertSqlCommandBuilder>();
        }
        
        /// <summary>
        /// Generates sql inset command for bunch of elements
        /// </summary>
        /// <param name="elements">elements that have to be inserted into the table</param>
        /// <param name="entityProfile">elements type profile (contains mapping and other options)</param>
        /// <param name="cancellationToken"></param>
        /// <returns>Returns a text of an sql inset command</returns>
        public string Generate<TEntity>([NotNull] ICollection<TEntity> elements, [NotNull] EntityProfile entityProfile, CancellationToken cancellationToken)
            where TEntity : class
        {
            var delimiter = "";
            var columns = "(";
            var firstColumn = true;
            var needReturning = false;
            foreach (var propInfo in entityProfile.Properties.Values)
            {
                if (propInfo.IsAutoGeneratedKey)
                {
                    needReturning = true;
                    continue;
                }
                delimiter = firstColumn
                    ? ""
                    : ", ";
                columns += $"\"{delimiter}{propInfo.DbColumnName}\"";

                firstColumn = false;
            }
            columns += ")";
            var command = $"insert into {entityProfile.TableName} ({columns}) values (";
            var approximateEntireCommandLength = command.Length + columns.Length * elements.Count;

            if (_logger.IsEnabled(LogLevel.Debug))
            {
                _logger.LogDebug($"{nameof(TEntity)}: {typeof(TEntity).FullName}");
                _logger.LogDebug($"{nameof(elements)}.Count: {elements.Count}");
                _logger.LogDebug($"approximateEntireCommandLength: {approximateEntireCommandLength}");
            }
            
            var resultBuilder = new StringBuilder(approximateEntireCommandLength);
            resultBuilder.Append(command);
            var firstItem = true;
            var paramIndex = 1;
            foreach (var item in elements)
            {
                var firstPropertyValue = true;
                foreach (var propInfo in entityProfile.Properties.Values)
                {
                    if (propInfo.IsAutoGeneratedKey)
                        continue;
                    delimiter = firstPropertyValue
                        ? ""
                        : ", ";
                    
                    var paramValue = GetValue(item, propInfo);
                    var paramName = $"@param{paramIndex++}";
                    
                    resultBuilder.Append('"');
                    resultBuilder.Append(delimiter);
                    resultBuilder.Append(paramName);
                    resultBuilder.Append('"');

                    firstPropertyValue = false;
                }

                resultBuilder.Append(')');
                //  Finished with properties 
                if (!firstItem)
                    resultBuilder.Append(", ");
                
                firstItem = false;
            }

            // TODO: add returning clause
            if (needReturning)
                GenerateReturning(resultBuilder, entityProfile);
            
            var result = resultBuilder.ToString();
            if (_logger.IsEnabled(LogLevel.Debug))
                _logger.LogDebug($"result command: {result}");
            
            return result;
        }

        /// <summary>
        /// Calculates value of an item's property
        /// </summary>
        /// <param name="item">item with values</param>
        /// <param name="propInfo">information about which property it is needed to get value</param>
        /// <typeparam name="TEntity">Type of entity</typeparam>
        /// <typeparam name="TValue">Type of property which value has to be calculated</typeparam>
        /// <returns>Returns</returns>
        private TValue GetValue<TEntity, TValue>(TEntity item, PropertyProfile propInfo)
            where TEntity : class
        {
            // TODO: make funcation dependent to a particular type of property
            var idMemberExpression = propInfo.PropertyExpresion;
            var convert = Expression.Convert(idMemberExpression, idMemberExpression.Type);
            var lambda = Expression.Lambda<TEntity, TValue>(convert, idMemberExpression.Expression as ParameterExpression);
            var value = lambda.Compile().Invoke(item);
            return value;
        }
    }
}